"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendTransactionAsBundleRpc = sendTransactionAsBundleRpc;
const transaction_service_1 = require("../transaction.service");
async function sendTransactionAsBundleRpc({ versionedTransactions, txOpts, connection, onCallback, blockStrategy, confirmCommitment, isSequentialTxs, throwError = false, }) {
    let signatures = [];
    if (isSequentialTxs) {
        for (const [index, tx] of versionedTransactions.entries()) {
            const signature = await connection.sendTransaction(tx, txOpts);
            try {
                await (0, transaction_service_1.confirmTransaction)(connection, signature, confirmCommitment);
                onCallback?.(index, true, signature);
            }
            catch (error) {
                onCallback?.(index, false, signature);
                throw error;
            }
            signatures.push(signature);
        }
    }
    else {
        signatures = await Promise.all(versionedTransactions.map(async (versionedTransaction) => {
            const signature = await connection.sendTransaction(versionedTransaction, txOpts);
            return signature;
        }));
        await Promise.all(signatures.map(async (signature, index) => {
            try {
                const result = await (0, transaction_service_1.confirmTransaction)(connection, signature, confirmCommitment);
                onCallback?.(index, true, signature);
                return result;
            }
            catch (error) {
                onCallback?.(index, false, signature);
                throw error;
            }
        }));
    }
    return signatures;
}
