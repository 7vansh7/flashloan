"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SendBundleError = void 0;
exports.sendTransactionAsGrpcBundle = sendTransactionAsGrpcBundle;
exports.sendTransactionAsBundle = sendTransactionAsBundle;
const mrgn_common_1 = require("@mrgnlabs/mrgn-common");
const transaction_service_1 = require("../transaction.service");
class SendBundleError extends Error {
    constructor(message, bundleId) {
        super(message);
        Object.setPrototypeOf(this, new.target.prototype); // Restore prototype chain
        this.bundleId = bundleId;
        Error.captureStackTrace(this, this.constructor);
    }
}
exports.SendBundleError = SendBundleError;
const GRPC_ERROR_TAG = "GRPC bundle failed:";
async function sendTransactionAsGrpcBundle(connection, base58Txs, throwError = false) {
    try {
        const sendBundleResponse = await fetch("/api/bundles/sendBundle", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                transactions: base58Txs,
            }),
        });
        const sendBundleResult = await sendBundleResponse.json();
        if (sendBundleResult.error)
            throw new SendBundleError(sendBundleResult.error, sendBundleResult?.bundleId);
        const bundleId = sendBundleResult.bundleId;
        // confirm bundle
        try {
            await (0, transaction_service_1.confirmBundle)(connection, bundleId);
        }
        catch (error) {
            return bundleId;
        }
        return bundleId;
    }
    catch (error) {
        if (throwError) {
            if (error instanceof SendBundleError)
                throw error;
            throw new SendBundleError(`${GRPC_ERROR_TAG} unknown error`);
        }
    }
}
const API_ERROR_TAG = "API bundle failed:";
async function sendTransactionAsBundle(connection, base58Txs, throwError = false, tempBundleId) {
    try {
        const sendBundleResponse = await fetch("https://mainnet.block-engine.jito.wtf/api/v1/bundles", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                jsonrpc: "2.0",
                id: 1,
                method: "sendBundle",
                params: [base58Txs],
            }),
        });
        const sendBundleResult = await sendBundleResponse.json();
        if (sendBundleResult.error) {
            if (sendBundleResult.error.message.includes("already processed")) {
                return tempBundleId ?? "0x0"; // todo add proper bundle id
            }
            throw new SendBundleError(`${API_ERROR_TAG} ${sendBundleResult.error.message}`);
        }
        const bundleId = sendBundleResult.result;
        await (0, mrgn_common_1.sleep)(500);
        for (let attempt = 0; attempt < 10; attempt++) {
            const getBundleStatusInFlightResponse = await fetch("https://mainnet.block-engine.jito.wtf/api/v1/bundles", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    jsonrpc: "2.0",
                    id: 1,
                    method: "getInflightBundleStatuses",
                    params: [[bundleId]],
                }),
            });
            const getBundleStatusInFlightResult = await getBundleStatusInFlightResponse.json();
            if (getBundleStatusInFlightResult.error)
                throw new Error(getBundleStatusInFlightResult.error.message);
            const status = getBundleStatusInFlightResult?.result?.value[0]?.status;
            /**
             * Bundle status values:
             * - Failed: All regions marked bundle as failed, not forwarded
             * - Pending: Bundle has not failed, landed, or been deemed invalid
             * - Landed: Bundle successfully landed on-chain (verified via RPC/bundles_landed table)
             * - Invalid: Bundle is no longer in the system
             */
            if (status === "Failed") {
                throw new SendBundleError(`${API_ERROR_TAG} unknown error`);
            }
            else if (status === "Landed") {
                await (0, transaction_service_1.confirmBundle)(connection, bundleId);
                return bundleId;
            }
            await (0, mrgn_common_1.sleep)(500); // Wait before retrying
        }
    }
    catch (error) {
        if (throwError) {
            if (error instanceof SendBundleError)
                throw error;
            throw new SendBundleError(`${API_ERROR_TAG} unknown error`);
        }
    }
}
